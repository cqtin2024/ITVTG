<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Tournament Management (GitHub Sync)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Base styles for Dark Mode */
        :root {
            --bg-color: #111827; /* Gray-900 */
            --text-color: #f3f4f6; /* Gray-100 */
            --card-bg: #1f2937; /* Gray-800 */
            --border-color: #374151; /* Gray-700 */
            --accent-color: #06b6d4; /* Cyan-500 */
            --match-bg: #1f2937;
            --input-bg: #4b5563; /* Gray-600 */
            --group-header-text: #60a5fa; /* Blue-400 */
        }
        
        /* Light Mode Overrides */
        .light-mode {
            --bg-color: #f9fafb; /* Gray-50 */
            --text-color: #111827; /* Gray-900 */
            --card-bg: #ffffff; /* White */
            --border-color: #e5e7eb; /* Gray-200 */
            --accent-color: #0ea5e9; /* Sky-500 */
            --match-bg: #f3f4f6; /* Gray-100 */
            --input-bg: #e5e7eb; /* Gray-200 */
            --group-header-text: #1d4ed8; /* Blue-700 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
        }

        .score-input, .text-input {
            background-color: var(--input-bg);
            color: var(--text-color);
        }

        .tab-button {
            transition: all 0.2s;
        }

        .tab-button.active {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }
        
        .match-card {
            background-color: var(--match-bg);
        }

        .group-header {
            color: var(--group-header-text);
        }
        
        /* Utility for mobile swipe */
        #app {
            overflow-x: hidden;
        }

        .tab-content {
            width: 100%;
            flex-shrink: 0;
            transition: transform 0.3s ease-in-out;
        }
        
        .active-tab-container {
            display: flex;
            width: 500%; /* For 5 tabs: Group, QF, SF, Final, Settings */
        }
    </style>
</head>
<body class="p-4">
    <div id="app" class="max-w-4xl mx-auto">
        
        <header class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold text-accent-color">Pickleball Tour</h1>
            <button id="themeToggle" class="p-2 rounded-full card">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            </button>
        </header>

        <div class="flex border-b border-border-color mb-4 sticky top-0 bg-bg-color z-10">
            <button class="tab-button flex-1 py-2 px-1 text-sm font-medium border-b-2 border-transparent active" data-tab="group">V√≤ng B·∫£ng</button>
            <button class="tab-button flex-1 py-2 px-1 text-sm font-medium border-b-2 border-transparent" data-tab="qf">T·ª© k·∫øt</button>
            <button class="tab-button flex-1 py-2 px-1 text-sm font-medium border-b-2 border-transparent" data-tab="sf">B√°n k·∫øt</button>
            <button class="tab-button flex-1 py-2 px-1 text-sm font-medium border-b-2 border-transparent" data-tab="final">Chung k·∫øt & Gi·∫£i</button>
            <button class="tab-button flex-1 py-2 px-1 text-sm font-medium border-b-2 border-transparent" data-tab="settings">C√†i ƒë·∫∑t</button>
        </div>
        
        <div class="overflow-hidden">
            <div id="tabContentContainer" class="active-tab-container">
                <div id="group" class="tab-content">
                    </div>
                
                <div id="qf" class="tab-content hidden">
                    <h2 class="text-xl font-bold mb-3 group-header">T·ª® K·∫æT</h2>
                    <div id="quarterfinals-matches" class="space-y-4"></div>
                </div>

                <div id="sf" class="tab-content hidden">
                    <h2 class="text-xl font-bold mb-3 group-header">B√ÅN K·∫æT</h2>
                    <div id="semifinals-matches" class="space-y-4"></div>
                </div>
                
                <div id="final" class="tab-content hidden">
                    <h2 class="text-xl font-bold mb-3 group-header">CHUNG K·∫æT</h2>
                    <div id="final-match" class="space-y-4"></div>
                    <div id="final-ranks-summary" class="mt-8 p-4 card">
                        <h3 class="text-lg font-bold mb-3 group-header">X·∫æP H·∫†NG CHUNG CU·ªòC</h3>
                        </div>
                </div>

                <div id="settings" class="tab-content hidden">
                    <h2 class="text-xl font-bold mb-4 group-header">C√ÄI ƒê·∫∂T & ƒê·ªíNG B·ªò</h2>
                    <div class="card p-4 mb-4 space-y-3">
                        <h3 class="text-lg font-semibold">C·∫•u h√¨nh GitHub</h3>
                        <input id="githubRepo" type="text" placeholder="T√™n repo (vd: user/repo)" class="text-input w-full p-2 rounded" value="">
                        <input id="githubBranch" type="text" placeholder="Branch (vd: main)" class="text-input w-full p-2 rounded" value="main">
                        <input id="githubToken" type="password" placeholder="Token c√° nh√¢n (Personal Access Token)" class="text-input w-full p-2 rounded">
                        <div class="flex space-x-2">
                            <button onclick="saveGitHubSettings()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition">L∆∞u C·∫•u h√¨nh</button>
                            <button onclick="loadDataFromGitHub()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition">T·∫£i d·ªØ li·ªáu</button>
                        </div>
                    </div>

                    <div class="card p-4 space-y-3">
                        <h3 class="text-lg font-semibold">Thao t√°c D·ªØ li·ªáu</h3>
                        <button onclick="commitChanges()" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded transition">ƒê·ªíNG B·ªò L√äN GITHUB</button>
                        <button onclick="reSyncStaticDataPrompt()" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded transition">L√†m m·ªõi C·∫•u tr√∫c Gi·∫£i (C·∫®N TH·∫¨N)</button>
                        <button onclick="clearLocalStorage()" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition">X√≥a C·∫•u h√¨nh ƒê√£ L∆∞u</button>
                    </div>
                    
                    <p class="text-sm text-gray-400 mt-4" id="lastSyncStatus">Ch∆∞a ƒë·ªìng b·ªô.</p>
                </div>
            </div>
        </div>
        
        <div id="confirmationBox" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-card p-6 rounded-lg shadow-xl max-w-sm mx-4">
                <h3 class="text-xl font-bold mb-4 text-red-400">C·∫¢NH B√ÅO</h3>
                <p class="mb-4">B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën **L√ÄM M·ªöI C·∫§U TR√öC GI·∫¢I ƒê·∫§U** t·ª´ file `state3.json` kh√¥ng? Thao t√°c n√†y s·∫Ω **X√ìA H·∫æT M·ªåI T·ªà S·ªê ƒê√É NH·∫¨P**.</p>
                <div class="flex justify-end space-x-3">
                    <button id="confirmNo" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">H·ªßy</button>
                    <button id="confirmYes" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">ƒê·ªíNG √ù (X√≥a T·ªâ s·ªë)</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let tournamentData = null; // D·ªØ li·ªáu state3.json (c·∫•u tr√∫c g·ªëc)
        let scoreDiffData = {};    // D·ªØ li·ªáu state3s.json (t·ªâ s·ªë ƒë√£ thay ƒë·ªïi)
        let githubConfig = {};
        let currentTab = 'group';
        let startX = 0;
        let endX = 0;
        
        const GROUP_ORDER = ['A', 'B', 'C', 'D'];
        const GROUP_SCORE_WIN = 3;
        
        // --- UTILITY FUNCTIONS ---
        function getGitHubConfig() {
            try {
                const config = localStorage.getItem('githubConfig');
                if (config) {
                    githubConfig = JSON.parse(config);
                } else {
                    githubConfig = { repo: '', branch: 'main', token: '' };
                }
            } catch (e) {
                console.error("Error loading config:", e);
                githubConfig = { repo: '', branch: 'main', token: '' };
            }
        }
        
        function saveGitHubSettings() {
            githubConfig.repo = document.getElementById('githubRepo').value.trim();
            githubConfig.branch = document.getElementById('githubBranch').value.trim() || 'main';
            // Kh√¥ng l∆∞u Token n·∫øu n√≥ l√† '********' (ch·ªâ thay ƒë·ªïi khi ng∆∞·ªùi d√πng nh·∫≠p m·ªõi)
            const tokenInput = document.getElementById('githubToken').value.trim();
            if (tokenInput !== '********') {
                githubConfig.token = tokenInput;
            }
            localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
            alert('ƒê√£ l∆∞u c·∫•u h√¨nh GitHub!');
            loadDataFromGitHub(); // T·∫£i l·∫°i d·ªØ li·ªáu sau khi l∆∞u config
        }
        
        function clearLocalStorage() {
            localStorage.removeItem('githubConfig');
            localStorage.removeItem('darkMode');
            alert('ƒê√£ x√≥a c·∫•u h√¨nh GitHub v√† Theme ƒë√£ l∆∞u.');
            window.location.reload();
        }

        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-mode');
            const isLight = body.classList.contains('light-mode');
            localStorage.setItem('darkMode', !isLight); // L∆∞u tr·∫°ng th√°i ng∆∞·ª£c l·∫°i
        }
        
        function applyTheme() {
            const isDark = localStorage.getItem('darkMode') !== 'false'; // M·∫∑c ƒë·ªãnh l√† Dark
            if (!isDark) {
                 document.body.classList.add('light-mode');
            }
        }
        
        // --- GITHUB API FUNCTIONS ---
        
        async function fetchGitHubFile(filename) {
            if (!githubConfig.repo || !githubConfig.token) {
                console.error(`Missing GitHub config for ${filename}`);
                // B·ªè qua l·ªói 404 cho state3s.json (d·ªØ li·ªáu t·ªâ s·ªë c√≥ th·ªÉ ch∆∞a t·ªìn t·∫°i)
                if (filename === 'state3s.json') return {}; 
                document.getElementById('lastSyncStatus').textContent = 'L·ªñI: Vui l√≤ng nh·∫≠p c·∫•u h√¨nh GitHub v√† Token h·ª£p l·ªá.';
                return null;
            }
            
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p branch kh√¥ng ƒë∆∞·ª£c ƒëi·ªÅn. M·∫∑c ƒë·ªãnh l√† main
            const branchRef = githubConfig.branch || 'main';
            const url = `https://api.github.com/repos/${githubConfig.repo}/contents/${filename}?ref=${branchRef}`;
            
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `token ${githubConfig.token}`,
                        'Accept': 'application/vnd.github.v3.raw'
                    }
                });
                
                if (!response.ok) {
                     // N·∫øu l√† state3s.json v√† kh√¥ng t·ªìn t·∫°i (404), tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng r·ªóng
                    if (filename === 'state3s.json' && response.status === 404) return {};
                    throw new Error(`GitHub API error for ${filename}: ${response.statusText} (Status: ${response.status})`);
                }
                
                const data = await response.json();
                document.getElementById('lastSyncStatus').textContent = `T·∫£i file ${filename} th√†nh c√¥ng l√∫c: ${new Date().toLocaleTimeString()}`;
                return data;
            } catch (error) {
                console.error(`Error fetching ${filename}:`, error.message);
                document.getElementById('lastSyncStatus').textContent = `L·ªñI t·∫£i file ${filename}: ${error.message}`;
                return null;
            }
        }
        
        async function getFileSha(filename) {
            if (!githubConfig.repo || !githubConfig.token) return null;
             
            const branchRef = githubConfig.branch || 'main';
            const url = `https://api.github.com/repos/${githubConfig.repo}/contents/${filename}?ref=${branchRef}`;
            
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `token ${githubConfig.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!response.ok) {
                     // N·∫øu file ch∆∞a t·ªìn t·∫°i (404), tr·∫£ v·ªÅ null (kh√¥ng ph·∫£i l·ªói)
                    if (response.status === 404) return null;
                    throw new Error(`GitHub API error for SHA ${filename}: ${response.statusText}`);
                }
                
                const data = await response.json();
                return data.sha;
            } catch (error) {
                console.error(`Error fetching SHA for ${filename}:`, error.message);
                return null;
            }
        }
        
        async function uploadGitHubFile(filename, content, commitMessage) {
            if (!githubConfig.repo || !githubConfig.token) {
                alert('L·ªói: Thi·∫øu c·∫•u h√¨nh Repo ho·∫∑c Token GitHub.');
                return false;
            }
            
            const sha = await getFileSha(filename);
            const contentBase64 = btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2))));
            
            const data = {
                message: commitMessage,
                content: contentBase64,
                branch: githubConfig.branch || 'main'
            };
            
            if (sha) {
                data.sha = sha; // Ch·ªâ th√™m SHA n·∫øu file ƒë√£ t·ªìn t·∫°i
            }
            
            const url = `https://api.github.com/repos/${githubConfig.repo}/contents/${filename}`;
            
            try {
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${githubConfig.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Upload failed for ${filename}: ${response.statusText}. Details: ${JSON.stringify(errorData)}`);
                }
                
                document.getElementById('lastSyncStatus').textContent = `ƒê·ªíNG B·ªò ${filename} th√†nh c√¥ng l√∫c: ${new Date().toLocaleTimeString()}`;
                return true;
            } catch (error) {
                console.error(`Error uploading ${filename}:`, error.message);
                alert(`L·ªñI ƒê·ªíNG B·ªò ${filename}: ${error.message}`);
                return false;
            }
        }
        
        async function loadDataFromGitHub() {
            getGitHubConfig();
            
            if (!githubConfig.repo || !githubConfig.token) {
                document.getElementById('lastSyncStatus').textContent = 'Vui l√≤ng nh·∫≠p c·∫•u h√¨nh GitHub v√† nh·∫•n "L∆∞u C·∫•u h√¨nh".';
                return;
            }

            // 1. T·∫£i state3.json (C·∫•u tr√∫c g·ªëc)
            const staticData = await fetchGitHubFile('state3.json');
            
            if (!staticData) {
                 // N·∫øu kh√¥ng t·∫£i ƒë∆∞·ª£c c·∫•u tr√∫c g·ªëc, d·ª´ng l·∫°i v√† ch·ªâ hi·ªÉn th·ªã giao di·ªán m·∫∑c ƒë·ªãnh
                tournamentData = null;
                runAllLogic(); 
                return;
            }
            
            tournamentData = staticData;

            // 2. T·∫£i state3s.json (T·ªâ s·ªë thay ƒë·ªïi)
            const diffData = await fetchGitHubFile('state3s.json');
            // diffData s·∫Ω l√† {} n·∫øu file kh√¥ng t·ªìn t·∫°i ho·∫∑c c√≥ l·ªói (xem fetchGitHubFile)
            scoreDiffData = diffData || {}; 
            
            runAllLogic();
        }
        
        // --- MATCH & SCORE LOGIC ---
        
        function calculateWinner(match, includeScoreDiff = true) {
            let sA, sB;
            if (includeScoreDiff) {
                const diff = scoreDiffData[match.Id] || {};
                sA = diff.sA !== undefined ? diff.sA : match.sA;
                sB = diff.sB !== undefined ? diff.sB : match.sB;
            } else {
                sA = match.sA;
                sB = match.sB;
            }

            // Ch·ªâ t√≠nh n·∫øu c√≥ ƒë·ªß ƒëi·ªÉm h·ª£p l·ªá
            if (sA === null || sB === null || isNaN(sA) || isNaN(sB)) {
                return { winnerId: null, loserId: null };
            }

            if (sA > sB) {
                return { winnerId: match.pA, loserId: match.pB };
            } else if (sB > sA) {
                return { winnerId: match.pB, loserId: match.pA };
            } else {
                return { winnerId: null, loserId: null }; // H√≤a ho·∫∑c ƒëi·ªÉm b·∫±ng nhau
            }
        }

        function updateScore(matchId, participant, score) {
            const scoreValue = parseInt(score);
            if (isNaN(scoreValue)) return; // B·ªè qua n·∫øu kh√¥ng ph·∫£i s·ªë
            
            // T√¨m tr·∫≠n ƒë·∫•u g·ªëc trong tournamentData (·ªü b·∫•t c·ª© ƒë√¢u)
            let match = findMatchById(matchId);
            if (!match) return;

            // C·∫≠p nh·∫≠t v√†o scoreDiffData
            if (!scoreDiffData[matchId]) {
                scoreDiffData[matchId] = {};
            }
            
            if (participant === 'pA') {
                scoreDiffData[matchId].sA = scoreValue;
            } else if (participant === 'pB') {
                scoreDiffData[matchId].sB = scoreValue;
            }

            // N·∫øu ƒë√¢y l√† tr·∫≠n Knockout, ph·∫£i ch·∫°y l·∫°i logic ƒë·ªÉ x√°c ƒë·ªãnh ƒë·ªôi ƒëi ti·∫øp
            if (match.round === 'quarterfinals' || match.round === 'semifinals' || match.round === 'final') {
                runAllLogic();
            } else {
                 // N·∫øu l√† tr·∫≠n V√≤ng B·∫£ng, ch·ªâ c·∫ßn ch·∫°y l·∫°i logic c·ªßa V√≤ng B·∫£ng v√† render l·∫°i
                recalculateAndSortGroupTables();
                renderGroupSection();
            }
        }
        
        function findMatchById(matchId) {
            if (!tournamentData) return null;
            
            // Ki·ªÉm tra v√≤ng b·∫£ng
            for (const groupKey in tournamentData.groups) {
                const group = tournamentData.groups[groupKey];
                const match = group.matches.find(m => m.Id === matchId);
                if (match) {
                    match.round = 'group';
                    return match;
                }
            }
            
            // Ki·ªÉm tra v√≤ng Knockout
            const rounds = ['quarterfinals', 'semifinals', 'final'];
            for (const round of rounds) {
                const matches = tournamentData[round];
                if (matches && Array.isArray(matches)) {
                    const match = matches.find(m => m.Id === matchId);
                    if (match) {
                        match.round = round;
                        return match;
                    }
                } else if (round === 'final' && matches && matches.Id === matchId) {
                    matches.round = round;
                    return matches;
                }
            }
            
            return null;
        }

        // --- GROUP STAGE LOGIC ---
        
        function recalculateAndSortGroupTables() {
            if (!tournamentData || !tournamentData.groups) return;

            for (const groupKey in tournamentData.groups) {
                const group = tournamentData.groups[groupKey];
                const teams = {};

                // Kh·ªüi t·∫°o b·∫£ng th·ªëng k√™ cho t·ª´ng ƒë·ªôi
                group.teams.forEach(team => {
                    teams[team.Id] = {
                        ...team,
                        P: 0, W: 0, D: 0, L: 0, 
                        PF: 0, PA: 0, PD: 0, Pts: 0
                    };
                });

                // X·ª≠ l√Ω t·ª´ng tr·∫≠n ƒë·∫•u
                group.matches.forEach(match => {
                    const diff = scoreDiffData[match.Id] || {};
                    const sA = diff.sA !== undefined ? diff.sA : match.sA;
                    const sB = diff.sB !== undefined ? diff.sB : match.sB;
                    
                    if (sA === null || sB === null || isNaN(sA) || isNaN(sB)) return;

                    const teamA = teams[match.pA];
                    const teamB = teams[match.pB];

                    if (!teamA || !teamB) return; 

                    teamA.P++; teamB.P++;
                    teamA.PF += sA; teamA.PA += sB; teamA.PD += (sA - sB);
                    teamB.PF += sB; teamB.PA += sA; teamB.PD += (sB - sA);

                    if (sA > sB) {
                        teamA.W++; teamB.L++; teamA.Pts += GROUP_SCORE_WIN;
                    } else if (sB > sA) {
                        teamB.W++; teamA.L++; teamB.Pts += GROUP_SCORE_WIN;
                    } else {
                        teamA.D++; teamB.D++; // Kh√¥ng c√≥ ƒëi·ªÉm n·∫øu h√≤a (theo v√≠ d·ª•)
                    }
                });

                // S·∫Øp x·∫øp l·∫°i danh s√°ch ƒë·ªôi trong group
                const sortedTeams = Object.values(teams).sort((a, b) => {
                    // 1. S·ªë tr·∫≠n th·∫Øng (W)
                    if (b.W !== a.W) return b.W - a.W;
                    // 2. ƒêi·ªÉm t√≠ch l≈©y (Pts) - 3 ƒëi·ªÉm/th·∫Øng
                    if (b.Pts !== a.Pts) return b.Pts - a.Pts;
                    // 3. Hi·ªáu s·ªë ƒëi·ªÉm (PD)
                    if (b.PD !== a.PD) return b.PD - a.PD;
                    // 4. ƒêi·ªÉm ghi ƒë∆∞·ª£c (PF)
                    return b.PF - a.PF;
                });
                
                // C·∫≠p nh·∫≠t l·∫°i list team
                group.teams = sortedTeams;
                
                // X√°c ƒë·ªãnh 2 ƒë·ªôi ƒëi ti·∫øp
                if (group.teams.length >= 2) {
                    group.team1 = group.teams[0].Id;
                    group.team2 = group.teams[1].Id;
                } else {
                    group.team1 = null;
                    group.team2 = null;
                }
            }
        }
        
        // --- KNOCKOUT STAGE LOGIC ---
        
        function seedKnockoutMatches() {
            if (!tournamentData || !tournamentData.groups) return;
            
            const g = tournamentData.groups;
            
            // Ki·ªÉm tra v√† ƒëi·ªÅn c√°c ƒë·ªôi v√†o T·ª© k·∫øt
            if (tournamentData.quarterfinals && tournamentData.quarterfinals.length === 4) {
                // QF1: A1 vs B2
                tournamentData.quarterfinals[0].pA = g.A.team1;
                tournamentData.quarterfinals[0].pB = g.B.team2;
                
                // QF2: B1 vs A2
                tournamentData.quarterfinals[1].pA = g.B.team1;
                tournamentData.quarterfinals[1].pB = g.A.team2;
                
                // QF3: C1 vs D2
                tournamentData.quarterfinals[2].pA = g.C.team1;
                tournamentData.quarterfinals[2].pB = g.D.team2;
                
                // QF4: D1 vs C2
                tournamentData.quarterfinals[3].pA = g.D.team1;
                tournamentData.quarterfinals[3].pB = g.C.team2;
            }
        }
        
        function updateKnockoutMatches(round) {
            if (!tournamentData) return;
            
            let currentMatches, nextMatches;

            if (round === 'quarterfinals') {
                currentMatches = tournamentData.quarterfinals;
                nextMatches = tournamentData.semifinals;
            } else if (round === 'semifinals') {
                currentMatches = tournamentData.semifinals;
                nextMatches = tournamentData.final;
            } else if (round === 'final') {
                currentMatches = [tournamentData.final]; // ƒê∆∞a v√†o m·∫£ng ƒë·ªÉ x·ª≠ l√Ω d·ªÖ d√†ng
            } else {
                return;
            }

            currentMatches.forEach((match, index) => {
                const { winnerId, loserId } = calculateWinner(match, true);
                
                match.Wn = winnerId;

                // X√ÅC ƒê·ªäNH H·∫†NG BA & √Å QU√ÇN
                if (round === 'final') {
                    // Chung k·∫øt: rU l√† √Å qu√¢n
                    match.rU = loserId; 
                } else if (round === 'semifinals') { 
                    // B√°n k·∫øt: rU l√† ID ƒë·ªôi thua (s·∫Ω l√† h·∫°ng Ba ƒë·ªìng h·∫°ng)
                    match.rU = loserId; 
                } else {
                    // T·ª© k·∫øt: ƒê·∫£m b·∫£o rU l√† null
                    match.rU = null;
                }


                // Chuy·ªÉn ƒë·ªôi th·∫Øng sang v√≤ng ti·∫øp theo (tr·ª´ tr·∫≠n Chung k·∫øt)
                if (winnerId && round !== 'final' && nextMatches) {
                    let nextMatch;
                    let nextPos; // pA ho·∫∑c pB

                    if (Array.isArray(nextMatches)) { // T·ª© k·∫øt -> B√°n k·∫øt
                         // Logic ph·ª©c t·∫°p h∆°n n·∫øu kh√¥ng c√≥ tr∆∞·ªùng Pos r√µ r√†ng. Gi·∫£ ƒë·ªãnh Pos ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n bi·ªát.
                         nextMatch = nextMatches.find(m => m.Pos === match.Pos);
                         // X√°c ƒë·ªãnh v·ªã tr√≠ ti·∫øp theo (pA/pB) d·ª±a tr√™n v·ªã tr√≠ c·ªßa ng∆∞·ªùi th·∫Øng trong c·∫∑p ƒë·∫•u ti·∫øp theo
                         if (match.Pos === 'W_QF1' || match.Pos === 'W_QF2') { // QF1, QF2 -> SF1 (nextMatch l√† SF1)
                             if (index === 0) nextPos = 'pA'; // Ng∆∞·ªùi th·∫Øng QF1 l√† pA c·ªßa SF1
                             else if (index === 1) nextPos = 'pB'; // Ng∆∞·ªùi th·∫Øng QF2 l√† pB c·ªßa SF1
                         } else if (match.Pos === 'W_QF3' || match.Pos === 'W_QF4') { // QF3, QF4 -> SF2
                             if (index === 2) nextPos = 'pA'; // Ng∆∞·ªùi th·∫Øng QF3 l√† pA c·ªßa SF2
                             else if (index === 3) nextPos = 'pB'; // Ng∆∞·ªùi th·∫Øng QF4 l√† pB c·ªßa SF2
                         }

                    } else { // B√°n k·∫øt -> Chung k·∫øt
                        nextMatch = nextMatches; // nextMatches l√† ƒë·ªëi t∆∞·ª£ng final
                        // Gi·∫£ ƒë·ªãnh SF1 -> pA c·ªßa Final, SF2 -> pB c·ªßa Final
                        nextPos = match.Pos === 'W_SF1' ? 'pA' : 'pB';
                    }
                    
                    if (nextMatch) {
                        if (nextPos === 'pA') {
                            nextMatch.pA = winnerId;
                        } else if (nextPos === 'pB') {
                            nextMatch.pB = winnerId;
                        }
                    }
                }
            });
        }
        
        // H√ÄM M·ªöI X√ÅC ƒê·ªäNH H·∫†NG CU·ªêI C√ôNG
        function determineFinalRanks() {
            if (!tournamentData) return;

            const finalMatch = tournamentData.final;
            const semifinals = tournamentData.semifinals;
            
            const finalResults = {
                champion: null, // V√¥ ƒë·ªãch (Wn c·ªßa Final)
                runnerUp: null, // √Å qu√¢n (rU c·ªßa Final)
                thirdPlace: []  // Hai gi·∫£i Ba ƒë·ªìng h·∫°ng (rU c·ªßa Semifinals)
            };

            // 1. V√¥ ƒë·ªãch & √Å qu√¢n
            if (finalMatch && finalMatch.Wn && finalMatch.rU) {
                finalResults.champion = finalMatch.Wn; 
                finalResults.runnerUp = finalMatch.rU; 
            }

            // 2. Hai gi·∫£i Ba ƒë·ªìng h·∫°ng
            if (semifinals && Array.isArray(semifinals)) {
                semifinals.forEach(match => {
                    // ƒê·ªçc ID ƒë·ªôi thua (rU) t·ª´ 2 tr·∫≠n B√°n k·∫øt
                    if (match.rU) { 
                        finalResults.thirdPlace.push(match.rU);
                    }
                });
            }
            
            // L∆∞u k·∫øt qu·∫£ cu·ªëi c√πng v√†o ƒë·ªëi t∆∞·ª£ng d·ªØ li·ªáu gi·∫£i ƒë·∫•u
            tournamentData.finalRanks = finalResults;
        }

        // --- RENDER FUNCTIONS ---
        
        function getTeamName(id) {
            if (!tournamentData || !tournamentData.teams) return `[ƒê·ªôi ID: ${id}]`;
            const team = tournamentData.teams.find(t => t.Id === id);
            return team ? team.Name : `[ƒê·ªôi ID: ${id}]`;
        }
        
        function renderMatch(match, round) {
            // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu gi·∫£i ƒë·∫•u, hi·ªÉn th·ªã th·∫ª r·ªóng
            if (!tournamentData) return `<div class="match-card p-3 rounded-lg shadow-md flex justify-center text-gray-500">Ch∆∞a t·∫£i ƒë∆∞·ª£c c·∫•u tr√∫c gi·∫£i ƒë·∫•u. Vui l√≤ng ki·ªÉm tra tab C√†i ƒë·∫∑t.</div>`;
            
            const diff = scoreDiffData[match.Id] || {};
            const sA = diff.sA !== undefined ? diff.sA : match.sA;
            const sB = diff.sB !== undefined ? diff.sB : match.sB;
            
            const teamAId = match.pA;
            const teamBId = match.pB;
            
            const teamAName = getTeamName(teamAId);
            const teamBName = getTeamName(teamBId);
            
            const winnerClassA = (match.Wn && match.Wn === teamAId) ? 'font-bold text-accent-color' : '';
            const winnerClassB = (match.Wn && match.Wn === teamBId) ? 'font-bold text-accent-color' : '';

            // N·∫øu ch∆∞a x√°c ƒë·ªãnh pA ho·∫∑c pB (v√≤ng Knockout ch∆∞a ƒë·ªß ƒë·ªôi)
            const teamALabel = teamAId ? teamAName : (match.pA_Pos || match.Pos ? `(${match.pA_Pos || match.Pos.replace('W_', 'Th·∫Øng ')})` : 'Ch·ªù ƒë·ªôi...');
            const teamBLabel = teamBId ? teamBName : (match.pB_Pos ? `(${match.pB_Pos.replace('W_', 'Th·∫Øng ')})` : 'Ch·ªù ƒë·ªôi...');
            
            return `
                <div class="match-card p-3 rounded-lg shadow-md flex justify-between items-center space-x-2">
                    <div class="flex-1 space-y-2">
                        <div class="flex items-center space-x-2">
                            <span class="flex-1 truncate ${winnerClassA}">${teamALabel}</span>
                            <input 
                                type="number" 
                                min="0"
                                value="${sA !== null ? sA : ''}"
                                class="score-input w-16 p-1 text-center rounded text-base focus:outline-none focus:ring-2 focus:ring-accent-color"
                                onchange="updateScore('${match.Id}', 'pA', this.value)"
                                ${!teamAId ? 'disabled' : ''}
                            />
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="flex-1 truncate ${winnerClassB}">${teamBLabel}</span>
                            <input 
                                type="number" 
                                min="0"
                                value="${sB !== null ? sB : ''}"
                                class="score-input w-16 p-1 text-center rounded text-base focus:outline-none focus:ring-2 focus:ring-accent-color"
                                onchange="updateScore('${match.Id}', 'pB', this.value)"
                                ${!teamBId ? 'disabled' : ''}
                            />
                        </div>
                    </div>
                </div>
            `;
        }

        function renderGroupSection() {
            const groupDiv = document.getElementById('group');
            if (!tournamentData || !tournamentData.groups) {
                groupDiv.innerHTML = `<div class="text-center py-12 text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu v√≤ng b·∫£ng. Vui l√≤ng t·∫£i t·ª´ GitHub (tab C√†i ƒë·∫∑t).</div>`;
                return;
            }
            
            let html = '';

            GROUP_ORDER.forEach(groupKey => {
                const group = tournamentData.groups[groupKey];
                if (!group) return;

                // 1. Render B·∫£ng X·∫øp H·∫°ng
                html += `
                    <div class="mb-6 card p-3 rounded-lg shadow-xl">
                        <h3 class="text-xl font-bold mb-3 group-header">B·∫¢NG ${groupKey}</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-sm">
                                <thead class="border-b border-border-color">
                                    <tr class="text-left font-semibold">
                                        <th class="py-2 px-1">#</th>
                                        <th class="py-2 px-1">ƒê·ªôi</th>
                                        <th class="py-2 px-1 text-center">P</th>
                                        <th class="py-2 px-1 text-center">W</th>
                                        <th class="py-2 px-1 text-center">PD</th>
                                        <th class="py-2 px-1 text-center">Pts</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                group.teams.forEach((team, index) => {
                    const rankClass = (index === 0 || index === 1) ? 'font-bold text-accent-color' : '';
                    html += `
                        <tr class="border-b border-border-color/50">
                            <td class="py-2 px-1 ${rankClass}">${index + 1}</td>
                            <td class="py-2 px-1 truncate max-w-[100px] ${rankClass}">${team.Name}</td>
                            <td class="py-2 px-1 text-center">${team.P}</td>
                            <td class="py-2 px-1 text-center">${team.W}</td>
                            <td class="py-2 px-1 text-center">${team.PD > 0 ? '+' : ''}${team.PD}</td>
                            <td class="py-2 px-1 text-center ${rankClass}">${team.Pts}</td>
                        </tr>
                    `;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                
                // 2. Render Tr·∫≠n ƒê·∫•u
                html += `<h4 class="text-lg font-semibold mb-2 group-header">Tr·∫≠n ƒë·∫•u B·∫£ng ${groupKey}</h4>`;
                html += '<div class="space-y-3 mb-6">';
                group.matches.forEach(match => {
                    html += renderMatch(match, 'group');
                });
                html += '</div>';
            });

            groupDiv.innerHTML = html;
        }

        function renderKnockoutSection(round) {
            const containerId = round + '-matches';
            const container = document.getElementById(containerId);
            if (!tournamentData || !tournamentData[round]) {
                if (container) container.innerHTML = `<div class="text-center py-6 text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu v√≤ng ${round}.</div>`;
                return;
            }
            
            let html = '';
            
            if (round === 'final') {
                html = renderMatch(tournamentData.final, 'final');
            } else { 
                tournamentData[round].forEach(match => {
                    html += renderMatch(match, round);
                });
            }

            if (container) container.innerHTML = html;
        }
        
        function renderFinalSection() {
            // Render tr·∫≠n Chung k·∫øt tr∆∞·ªõc
            renderKnockoutSection('final');
            
            const summaryDiv = document.getElementById('final-ranks-summary');
            let html = '<ul class="space-y-3 font-semibold">';

            if (tournamentData && tournamentData.finalRanks) {
                const ranks = tournamentData.finalRanks;
                
                // 1. V√¥ ƒë·ªãch
                html += `
                    <li class="p-3 bg-yellow-900/50 rounded-lg flex justify-between items-center">
                        <span class="text-xl text-yellow-300">ü•á V√î ƒê·ªäCH</span>
                        <span class="text-xl text-yellow-300">${ranks.champion ? getTeamName(ranks.champion) : 'Ch∆∞a c√≥'}</span>
                    </li>
                `;
                
                // 2. √Å qu√¢n
                html += `
                    <li class="p-3 bg-gray-700/50 rounded-lg flex justify-between items-center">
                        <span class="text-lg text-gray-300">ü•à √Å QU√ÇN</span>
                        <span class="text-lg text-gray-300">${ranks.runnerUp ? getTeamName(ranks.runnerUp) : 'Ch∆∞a c√≥'}</span>
                    </li>
                `;
                
                // 3. Hai gi·∫£i Ba ƒë·ªìng h·∫°ng
                html += `
                    <li class="p-3 bg-amber-700/50 rounded-lg">
                        <span class="block text-md text-amber-300 mb-2">ü•â H·∫†NG BA ƒê·ªíNG H·∫†NG</span>
                        <ul class="ml-4 space-y-1">
                            ${ranks.thirdPlace.map(id => 
                                `<li class="text-amber-200">${getTeamName(id)}</li>`
                            ).join('')}
                            ${ranks.thirdPlace.length < 2 ? `<li class="text-amber-200">Ch∆∞a ƒë·ªß ƒë·ªôi</li>` : ''}
                        </ul>
                    </li>
                `;
                
            } else {
                 html += `<li class="text-center text-gray-400">Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ x·∫øp h·∫°ng chung cu·ªôc.</li>`;
            }

            html += '</ul>';
            summaryDiv.innerHTML = `<h3 class="text-lg font-bold mb-3 group-header">X·∫æP H·∫†NG CHUNG CU·ªòC</h3>${html}`;
        }


        // --- MAIN LOGIC FLOW ---
        
        function runAllLogic() {
            if (!tournamentData) {
                 renderAllSections();
                 updateDiffData();
                 return;
            }
            
            // 1. V√≤ng B·∫£ng
            recalculateAndSortGroupTables(); 
            
            // 2. V√≤ng Knockout: Gieo h·∫°t (chuy·ªÉn ƒë·ªôi t·ª´ V√≤ng B·∫£ng)
            seedKnockoutMatches();
            
            // 3. C·∫≠p nh·∫≠t k·∫øt qu·∫£ Knockout (theo th·ª© t·ª±)
            updateKnockoutMatches('quarterfinals');
            updateKnockoutMatches('semifinals');
            updateKnockoutMatches('final');
            
            // 4. T√çNH TO√ÅN X·∫æP H·∫†NG CU·ªêI C√ôNG
            determineFinalRanks(); 

            // 5. Render v√† chu·∫©n b·ªã ƒë·ªìng b·ªô
            renderAllSections();
            updateDiffData();
        }

        function renderAllSections() {
            renderGroupSection();
            renderKnockoutSection('quarterfinals');
            renderKnockoutSection('semifinals');
            renderFinalSection();
        }

        function updateDiffData() {
            const commitButton = document.querySelector('button[onclick="commitChanges()"]');
            if (!commitButton) return;

            if (Object.keys(scoreDiffData).length > 0) {
                 commitButton.textContent = `ƒê·ªíNG B·ªò L√äN GITHUB (${Object.keys(scoreDiffData).length} thay ƒë·ªïi)`;
                 commitButton.classList.add('bg-red-600', 'hover:bg-red-700');
                 commitButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700');
            } else {
                 commitButton.textContent = 'ƒê·ªíNG B·ªò L√äN GITHUB (Kh√¥ng thay ƒë·ªïi)';
                 commitButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                 commitButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            }
        }

        async function commitChanges() {
            if (Object.keys(scoreDiffData).length === 0) {
                alert('Kh√¥ng c√≥ thay ƒë·ªïi t·ªâ s·ªë n√†o ƒë·ªÉ ƒë·ªìng b·ªô.');
                return;
            }
            
            // Chu·∫©n b·ªã commit message
            const count = Object.keys(scoreDiffData).length;
            const commitMessage = `C·∫≠p nh·∫≠t t·ªâ s·ªë (${count} tr·∫≠n) - ${new Date().toLocaleString()}`;
            
            const success = await uploadGitHubFile('state3s.json', scoreDiffData, commitMessage);
            
            if (success) {
                // Sau khi upload th√†nh c√¥ng, x√≥a d·ªØ li·ªáu diff c≈© v√† t·∫£i l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
                scoreDiffData = {}; 
                updateDiffData(); // C·∫≠p nh·∫≠t l·∫°i n√∫t
                alert('ƒê·ªìng b·ªô t·ªâ s·ªë th√†nh c√¥ng!');
                loadDataFromGitHub();
            }
        }
        
        // --- DATA RESYNC UTILS ---
        
        function reSyncStaticDataPrompt() {
            document.getElementById('confirmationBox').classList.remove('hidden');
        }

        async function reSyncStaticData() {
            document.getElementById('confirmationBox').classList.add('hidden');
             const staticData = await fetchGitHubFile('state3.json');
             if (staticData) {
                 tournamentData = staticData;
                 scoreDiffData = {}; // X√≥a h·∫øt t·ªâ s·ªë c≈©
                 runAllLogic();
                 alert('ƒê√£ l√†m m·ªõi c·∫•u tr√∫c gi·∫£i ƒë·∫•u (state3.json) v√† x√≥a t·ªâ s·ªë (state3s.json).');
             }
        }


        // --- TAB & SWIPE LOGIC ---
        
        function changeTab(targetTabId) {
            currentTab = targetTabId;
            const tabs = ['group', 'qf', 'sf', 'final', 'settings'];
            const tabButtons = document.querySelectorAll('.tab-button');
            const container = document.getElementById('tabContentContainer');
            
            const tabIndex = tabs.indexOf(targetTabId);
            const offset = tabIndex * -20; // 100% / 5 tabs = 20%
            container.style.transform = `translateX(${offset}%)`;
            
            tabButtons.forEach(button => {
                button.classList.remove('active');
                button.classList.add('border-transparent');
                if (button.getAttribute('data-tab') === targetTabId) {
                    button.classList.add('active');
                    button.classList.remove('border-transparent');
                }
            });
            
             // Ch·ªâ ·∫©n/hi·ªán tab ƒëang ho·∫°t ƒë·ªông ƒë·ªÉ tr√°nh l·ªói render
            tabs.forEach(tabId => {
                const tabElement = document.getElementById(tabId);
                if (tabElement) {
                    if (tabId === targetTabId) {
                        tabElement.classList.remove('hidden');
                    } else {
                        tabElement.classList.add('hidden');
                    }
                }
            });
        }
        
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                changeTab(e.target.getAttribute('data-tab'));
            });
        });

        function handleGesture() {
            const tabs = ['group', 'qf', 'sf', 'final', 'settings'];
            const currentIndex = tabs.indexOf(currentTab);

            if (startX - endX > 50) { // Vu·ªët sang tr√°i (Chuy·ªÉn sang tab ti·∫øp theo)
                if (currentIndex < tabs.length - 1) {
                    changeTab(tabs[currentIndex + 1]);
                }
            } else if (endX - startX > 50) { // Vu·ªët sang ph·∫£i (Chuy·ªÉn sang tab tr∆∞·ªõc ƒë√≥)
                if (currentIndex > 0) {
                    changeTab(tabs[currentIndex - 1]);
                }
            }
        }


        // --- INITIALIZATION ---
        
        function initializeApp() {
            applyTheme();
            getGitHubConfig();
            
            // ƒêi·ªÅn th√¥ng tin setting ƒë√£ l∆∞u (n·∫øu c√≥)
            document.getElementById('githubRepo').value = githubConfig.repo || '';
            document.getElementById('githubBranch').value = githubConfig.branch || 'main';
            if (githubConfig.token) {
                 document.getElementById('githubToken').value = '********';
            }

            // Event listeners
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            document.getElementById('app').addEventListener('touchstart', (e) => {
                // ƒê·∫£m b·∫£o kh√¥ng k√≠ch ho·∫°t swipe khi ch·∫°m v√†o input
                if (e.target.classList.contains('score-input') || e.target.classList.contains('text-input')) return;
                startX = e.changedTouches[0].screenX;
            }, { passive: true });

            document.getElementById('app').addEventListener('touchend', (e) => {
                // ƒê·∫£m b·∫£o kh√¥ng k√≠ch ho·∫°t swipe khi ch·∫°m v√†o input
                if (e.target.classList.contains('score-input') || e.target.classList.contains('text-input')) return;
                endX = e.changedTouches[0].screenX;
                handleGesture();
            }, { passive: true });
            
            // Modal button setup
            document.getElementById('confirmYes').onclick = window.reSyncStaticData;
            document.getElementById('confirmNo').onclick = () => document.getElementById('confirmationBox').classList.add('hidden');
            
            // ----------------------------------------------------
            // KH·∫ÆC PH·ª§C QUAN TR·ªåNG: Kh·ªüi t·∫°o UI v√† Tab tr∆∞·ªõc khi t·∫£i Data
            // ----------------------------------------------------
            changeTab(currentTab); 
            renderAllSections(); 
            
            // B·∫Øt ƒë·∫ßu t·∫£i d·ªØ li·ªáu (s·∫Ω kh√¥ng l√†m h·ªèng UI n·∫øu l·ªói)
            loadDataFromGitHub();
        }

        window.onload = initializeApp;
    </script>
</body>
</html>
